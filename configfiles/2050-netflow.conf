# SOF-ELKÂ® Configuration File
# (C)2019 Lewes Technology Consulting, LLC
#
# This file contains filters, transforms, and enrichments for NetFlow records

filter {
  if [type] == "archive-netflow" {
    grok {
      patterns_dir => [ "/usr/local/sof-elk/grok-patterns" ]
      # nfdump2sof-elk.sh
      match => [ "message", "(?:%{IPORHOST:exporter})?(?:%{SPACE})?%{NONNEGINT:destination_as:int}%{SPACE}%{NONNEGINT:destination_mask:int}%{SPACE}%{NONNEGINT:engine_type:int}/%{NONNEGINT:engine_id:int}%{SPACE}%{TIMESTAMP_NETFLOW:first_switched_raw}%{SPACE}%{NONNEGINT:flow_records}%{SPACE}%{NONNEGINT}%{SPACE}%{NONNEGINT:in_bytes}%{SPACE}%{NONNEGINT:in_packets}%{SPACE}%{NONNEGINT:input_snmp:int}%{SPACE}%{IPV4:destination_ip}%{SPACE}%{IPV4:next_hop_ip}%{SPACE}%{IPV4:source_ip}%{SPACE}(%{ICMP_TYPECODE}|%{NONNEGINT:destination_port:int})%{SPACE}%{NONNEGINT:source_port:int}%{SPACE}%{TIMESTAMP_NETFLOW:last_switched_raw}%{SPACE}%{NONNEGINT:output_snmp:int}%{SPACE}%{WORD:protocol}%{SPACE}%{NONNEGINT}%{SPACE}%{NONNEGINT}%{SPACE}%{NONNEGINT:source_as:int}%{SPACE}%{NONNEGINT:source_mask:int}%{SPACE}%{NONNEGINT:source_tos:int}%{SPACE}%{NOTSPACE:tcp_flags}%{SPACE}%{NONNEGINT:version:int}" ]

      # vpcflow2sof-elk.sh
      match => [ "message", "%{INT:vpcflow_version} %{INT:vpcflow_account_id} %{NOTSPACE:vpcflow_interface_id} %{IPV4:source_ip} %{IPV4:destination_ip} %{INT:source_port} %{INT:destination_port} %{INT:protocol} %{INT:in_packets} %{INT:in_bytes} %{INT:first_switched_raw} %{INT:last_switched_raw} %{WORD:vpcflow_action} %{WORD:vpcflow_logstatus}" ]

      remove_field => [ "message", "MSECOND" ]
    }
    if ![exporter] {
      mutate {
        replace => { "exporter" => "0.0.0.0" }
      }
    }

    # use the flow start timestamp for the event timestamp
    ##  2014-05-11 16:25:11.841 (archived from nfdump)
    date {
      match => [ "first_switched_raw", "YYYY-MM-dd'THH:mm:ss.SSS'Z", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601", "UNIX" ]
    }

    ## unify timestamp formats between live and archive
    date {
      match => [ "first_switched_raw", "YYYY-MM-dd'THH:mm:ss.SSS'Z", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601", "UNIX" ]
      target => "first_switched"
    }
    date {
      match => [ "last_switched_raw", "YYYY-MM-dd'THH:mm:ss.SSS'Z", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601", "UNIX" ]
      target => "last_switched"
    }
    mutate {
      remove_field => [ "first_switched_raw", "last_switched_raw" ]
    }
  }

  if [type] == "netflow" {
    # remove the [nf] superfield, to better allow ES dynamic mappings
    # this method originally found here: https://discuss.elastic.co/t/netflow-codec-output-to-the-root-of-the-message/61954
    json_encode {
      source => "nf"
    }
    json {
      source => "nf"
      remove_field => [ "nf" ]
    }

    # rename fields as needed for better field naming hygeine
    mutate {
      rename => {
        "[host]" => "exporter"
        "[src_tos]" => "source_tos"
        "[l4_src_port]" => "source_port"
        "[ipv4_src_addr]" => "source_ip"
        "[src_mask]" => "source_mask"
        "[l4_dst_port]" => "destination_port"
        "[ipv4_dst_addr]" => "destination_ip"
        "[dst_mask]" => "destination_mask"
        "[ipv4_next_hop]" => "next_hop_ip"
        "[src_as]" => "source_as"
        "[dst_as]" => "destination_as"
        "[bgp_ipv4_next_hop]" => "bgp_next_hop_ip"
        "[mul_dst_pkts]" => "mul_destination_packets"
        "[mul_dst_bytes]" => "mul_destination_bytes"
        "[out_pkts]" => "out_packets"
        "[ipv6_src_addr]" => "source_ip"
        "[ipv6_dst_addr]" => "destination_ip"
        "[ipv6_src_mask]" => "source_mask"
        "[ipv6_dst_mask]" => "destination_mask"
        "[mpls_top_label_ip_addr]" => "mpls_top_label_ip"
        "[ipv4_ident]" => "ident"
        "[dst_tos]" => "destination_tos"
        "[in_src_mac]" => "in_source_mac"
        "[out_dst_mac]" => "out_destination_mac"
        "[src_vlan]" => "source_vlan"
        "[dst_vlan]" => "destination_vlan"
        "[ipv6_next_hop]" => "next_hop_ip"
        "[bgp_ipv6_next_hop]" => "bgp_next_hop_ip"
        "[ipv6_option_headers]" => "option_headers"
        "[in_dst_mac]" => "in_destination_mac"
        "[out_src_mac]" => "out_source_mac"
        "[flowStartSeconds]" => "first_switched"
        "[flowEndSeconds]" => "last_switched"
        "[flow_start_msec]" => "first_switched"
        "[flow_end_msec]" => "last_switched"
        "[flowStartMicroseconds]" => "first_switched"
        "[flowEndMicroseconds]" => "last_switched"
        "[flowStartNanoseconds]" => "first_switched"
        "[flowEndNanoseconds]" => "last_switched"
        "[flowDurationMilliseconds]" => "flow_duration"
        "[flowDurationMicroseconds]" => "flow_duration"
        "[observedFlowTotalCount]" => "flow_records"
        "[sourceIPv6Prefix]" => "source_prefix"
        "[icmp_type_ipv6]" => "icmp_type"
        "[icmp_code_ipv6]" => "icmp_code"
        "[udp_src_port]" => "source_port"
        "[udp_dst_port]" => "destination_port"
        "[tcp_src_port]" => "source_port"
        "[tcp_dst_port]" => "destination_port"
        "[tcpDestinationPort]" => "destination_port"
        "[xlate_src_addr_ipv4]" => "xlate_source_ip"
        "[xlate_dst_addr_ipv4]" => "xlate_destination_ip"
        "[xlate_src_addr_ipv6]" => "xlate_source_ip"
        "[xlate_dst_addr_ipv6]" => "xlate_destination_ip"
      }
    }

    # use the flow start timestamp for the event timestamp
    ##  2014-10-14T00:41:56.999Z (live netflow v5)
    ## 1555359537557 (live netflow v9)
    date {
      match => [ "first_switched", "YYYY-MM-dd'THH:mm:ss.SSS'Z", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601" , "UNIX_MS" ]
    }

    # Set up the first and last switched date values
    date {
      match => [ "first_switched", "YYYY-MM-dd'THH:mm:ss.SSS'Z", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601" , "UNIX_MS" ]
      target => "first_switched"
    }
    date {
      match => [ "last_switched", "YYYY-MM-dd'THH:mm:ss.SSS'Z", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601" , "UNIX_MS" ]
      target => "last_switched"
    }

    # convert the integer TCP flag value to an array, flag string, and hex byte
    if [tcp_flags] {
      ruby {
        path => "/usr/local/sof-elk/supporting-scripts/tcp_flags_to_array.rb"
        script_params => { "source_field" => "tcp_flags" }
      }
    }
  }

  if [type] == "netflow" or [type] == "archive-netflow" {
    # convert the text TCP flag string to an array and hex byte
    if [tcp_flags] {
      ruby {
        path => "/usr/local/sof-elk/supporting-scripts/tcp_flags_to_array.rb"
        script_params => { "source_field" => "tcp_flags" }
      }
    }

    # replace the numerical protocol number with a text equivalent
    translate {
      dictionary_path => "/usr/local/sof-elk/lib/dictionaries/ip_proto_int2netflow.yaml"
      field => "protocol"
      destination => "aprotocol"
    }

    # populate additional fields or modify as needed for other flow sources
    if ![flow_records] {
      mutate {
        add_field => { "flow_records" => "1" }
      }
    }
    if [flow_records] == "0" {
      mutate {
        replace => { "flow_records" => "1" }
      }
    }
    if ![missed_bytes] {
      mutate {
        add_field => { "missed_bytes" => "0" }
      }
    }
    if ![out_bytes] {
      mutate {
        add_field => { "out_bytes" => "0" }
      }
    }
    if ![out_packets] {
      mutate {
        add_field => { "out_packets" => "0" }
      }
    }

    # convert types
    if [in_bytes] {
      mutate {
        convert => { "in_bytes" => "integer" }
      }
    }
    if [out_bytes] {
      mutate {
        convert => { "out_bytes" => "integer" }
      }
    }
    if [flow_records] {
      mutate {
        convert => { "flow_records" => "integer" }
      }
    }
    if [in_packets] {
      mutate {
        convert => { "in_packets" => "integer" }
      }
    }
    if [out_packets] {
      mutate {
        convert => { "out_packets" => "integer" }
      }
    }
    if [missed_bytes] {
      mutate {
        convert => { "missed_bytes" => "integer" }
      }
    }

    mutate {
      add_field => { "path" => "NetFlow from %{exporter}" }

      # geoip needs IPs to be strings, not ip types
      convert => {
        "source_ip" => "string"
        "destination_ip" => "string"
      }
    }
  }

  if [type] == "archive-netflow" {
    if [aprotocol] == "icmp" {
      mutate {
        replace => { "source_port" => "%{icmp_type}" }
      }
      mutate {
        replace => { "destination_port" => "%{icmp_code}" }
      }
      mutate {
        remove_field => [ "icmp_type", "icmp_code" ]
      }
    }
  }
}
