# SOF-ELKÂ® Configuration File
# Author: Phil Hagen
# Email: phil@lewestech.com
#
# (C)2019 Lewes Technology Consulting, LLC
#
# This conf file accepts logs from the KAPE forensic tool

filter {
  if [type] == "kape_lnkfiles" and "json" not in [tags] {
    mutate {
      # create "source" and "target" superfields
      # promote necessary fields from the [raw] placeholder
      # remove the [raw] placeholder
      rename => {
        "[raw][SourceCreated]" => "[source][created]"
        "[raw][SourceModified]" => "[source][modified]"
        "[raw][SourceAccessed]" => "[source][accessed]"

        "[raw][TargetCreated]" => "[target][created]"
        "[raw][TargetModified]" => "[target][modified]"
        "[raw][TargetAccessed]" => "[target][accessed]"

        "[raw][SourceFile]" => "[source][filename]"
        "[raw][MachineMACAddress]" => "[source]machinemacaddress]"
        "[raw][MACVendor]" => "[source][macvendor]"
        "[raw][TrackerCreatedOn]" => "[source][Trackercreatedon]"

        "[raw][FileSize]" => "[target][filesize]"
        "[raw][Arguments]" => "[target][arguments]"
        "[raw][WorkingDirectory]" => "[target][workingdirectory]"
        "[raw][DriveType]" => "[target][drivetype]"
        "[raw][VolumeSerialNumber]" => "[target][volumeserialnumber]"
        "[raw][VolumeLabel]" => "[target][volumelabel]"
        "[raw][LocalPath]" => "[target][localpath]"
        "[raw][NetworkPath]" => "[target][networkpath]"
        "[raw][CommonPath]" => "[target][CommonPath]"
        "[raw][TargetIDAbsolutePath]" => "[target][absolutepath]"
        "[raw][TargetMFTEntryNumber]" => "[target][mftentrynumber]"
        "[raw][TargetMFTSequenceNumber]" => "[target][mftsequencenumber]"
        "[raw][MachineID]" => "[target][machineid]"
        "[raw][RelativePath]" => "[target][relativepath]"
      }
      remove_field => [ "raw" ]
    }

    # clean up known potentially empty fields
    if [Target][Created] == "" {
      mutate {
        remove_field => [ "[target][created]" ]
      }
    }
    if [Target][Modified] == "" {
      mutate {
        remove_field => [ "[target][modified]" ]
      }
    }
    if [Target][Accessed] == "" {
      mutate {
        remove_field => [ "[target][accessed]" ]
      }
    }

    # use the source last modified time for @timestamp
    date {
      match => [ "[source][modified]", "ISO8601" ]
    }

    # convert all timestamps to date/time types
    date {
      match => [ "[source][created]", "ISO8601" ]
      target => "[source][created]"
    }
    date {
      match => [ "[source][modified]", "ISO8601" ]
      target => "[source][modified]"
    }
    date {
      match => [ "[source][accessed]", "ISO8601" ]
      target => "[source][accessed]"
    }
    date {
      match => [ "[source][trackercreatedon]", "ISO8601" ]
      target => "[source][trackercreatedon]"
    }
    date {
      match => [ "[target][created]", "ISO8601" ]
      target => "[target][created]"
    }
    date {
      match => [ "[target][modified]", "ISO8601" ]
      target => "[target][modified]"
    }
    date {
      match => [ "[target][accessed]", "ISO8601" ]
      target => "[target][accessed]"
    }
  }
}