# SOF-ELK® Configuration File
# Created by Christophe Vandeplas <christophe@vandeplas.com>
# Please check https://github.com/cvandeplas/ELK-forensics for more information.
# Changes made by Mark Hallman 2019-03-20
# Changes made by Lewes Technology Consulting, LLC for the SOF-ELK® platform

# This file contains transforms and enrichments to be applied in postprocessing

filter {
  if [type] == "log2timeline" {
    csv {
       separator => ","
       quote_char => "ª"       # workaround: don't use a quote character as " gives issues if the field contains a "
       columns => ["date","time","timezone","macb","datasource","datasourcetype","eventtype","user","host","short","desc","version","filename","inode","notes","format","extra"]
    }
    if [date] == "date" {
       drop {}  # drop the first line that contains the column names
    }

    # assemble a string containing "<%date%> <%time%> <%timezone%>" go be used with the date{} filter
    mutate { merge => [ "date", "time" ] }       # merge and join need to be in separate mutates
    mutate { merge => [ "date", "timezone" ] }   # merge and join need to be in separate mutates
    mutate { join => [ "date", " " ] }           # merge and join need to be in separate mutates

    date {
      match => [ "date", "MM/dd/YYYY HH:mm:ss z" ]
    }

# PJH TODO: Do we need to unify this with stdinfo.* fields?
# PJH TODO: Holy crap... should we just alter KAPE to use one record per time value?  how does that affect $FILENAME?
#           this is an interesting option - it would require using the clone{} filter
    # extract macb info
    if ("M" in [macb]) { mutate { add_tag => [ "modified" ] } }
    if ("A" in [macb]) { mutate { add_tag => [ "accessed" ] } }
    if ("C" in [macb]) { mutate { add_tag => [ "changed" ] } }
    if ("B" in [macb]) { mutate { add_tag => [ "birth" ] } }

    # Extract filenames
    if [datasource] == "FILE" {
      grok {
        break_on_match => false
        match => [
          "desc", "(:(?<extracted.path>/.*?))?$",
          "extracted.path", "(?<extracted.filename>[^/]+?)?$",
          "extracted.filename", "((\.(?<extracted.ext>[^./]+))?)?$"
        ]
      }
    }

    if [datasource] == "META" {
      grok {
        break_on_match => false
        match => [
          "filename", "(:(?<extracted.path>/.*?))?$",
          "extracted.path", "(?<extracted.filename>[^/]+?)?$",
          "extracted.filename", "((\.(?<extracted.ext>[^./]+))?)?$"
        ]
      }
    }

    # Extract urls
    if [datasource] == "WEBHIST" {
      grok {
        match => [
          "desc", "Location: (?<extracted.url>.*?)[ $]"
        ]
      }
    }
    mutate {
      convert => [
        "inode", "integer",
        "version", "integer
      ]
      lowercase => [
        "extracted.ext"
      ]
      remove_field => [
        "message",
        "short",
        "date",
        "time",
        "timezone"
      ]
    }
  }
}